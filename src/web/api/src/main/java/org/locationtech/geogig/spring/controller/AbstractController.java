/* Copyright (c) 2017 Boundless and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/edl-v10.html
 *
 * Contributors:
 * Erik Merkle (Boundless) - initial implementation
 */
package org.locationtech.geogig.spring.controller;

import java.io.IOException;
import java.io.StringReader;

import javax.json.Json;
import javax.json.JsonObject;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpUtils;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.locationtech.geogig.rest.repository.ParameterSetFactory;
import org.locationtech.geogig.rest.repository.RepositoryProvider;
import org.locationtech.geogig.spring.dto.LegacyResponse;
import org.locationtech.geogig.web.api.ParameterSet;
import org.locationtech.geogig.web.api.StreamingWriter;
import org.locationtech.geogig.web.api.StreamingWriterFactory;
import org.slf4j.Logger;
import org.springframework.http.MediaType;
import org.springframework.http.RequestEntity;
import org.w3c.dom.Document;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import com.google.common.base.Optional;
import com.google.common.base.Throwables;

/**
 * Base Controller to hold common controller logic.
 */
public abstract class AbstractController {

    /**
     * Request parameter for requesting API version 2 responses. This is currently not supported
     * and may or may not ever come to fruition. If a controller wishes to support API version 2, it
     * should produce responses generated by the Spring MVC framework MessgaeConverters for
     * XML (JAXB2) and JSON (Google's Gson) when this parameter is in the request.
     */
    protected static final String API_V2 = "api_version=2";

    /**
     * Extracts the {@link RepositoryProvider} from the HTTP request. The {@link RepositoryProvider}
     * should be injected at server startup.
     *
     * @param request The request from which a RepositoryProvider should be extracted.
     *
     * @return An {@link Optional} of the RepositoryProvider from the request.
     */
    protected final Optional<RepositoryProvider> getRepoProvider(final HttpServletRequest request) {
        Object providerValue = request.getAttribute(RepositoryProvider.KEY);
        if (providerValue != null &&
                RepositoryProvider.class.isAssignableFrom(providerValue.getClass())) {
            return Optional.of((RepositoryProvider) providerValue);
        }
        return Optional.absent();
    }

    /**
     * Encodes the Response directly to the HTTP OutputStream. This method is to provide a way to
     * reuse the old Restlet Representation stream writing within the Spring MVC framework so that
     * the response format of GeoGig Web API requests remains the same.
     *
     * @param responseBean An encapsulated response object that can write itself to a
     *                     {@link StreamingWriter}.
     * @param request      The Request that produced the supplied responseBean.
     * @param response     The Response to which the responseBean should be written.
     */
    protected final void encode(LegacyResponse responseBean, final HttpServletRequest request,
            final HttpServletResponse response) {
        // Extract the baseURL from the request (NOTE: not reliable if proxies are involved)
        final String baseURL = getBaseUrl(request);
        // determine requested output format
        final MediaType requestedResponseFormat = getMediaType(request);
        // set the Content-Type since we aren't using Spring's framework here
        response.setContentType(requestedResponseFormat.toString());
        // write the LegacyResponse object out to the Response stream
        try (StreamingWriter streamWriter =
                StreamingWriterFactory.getStreamWriter(requestedResponseFormat,
                        response.getWriter())) {
            streamWriter.writeStartDocument();
            responseBean.encode(streamWriter, requestedResponseFormat, baseURL);
            streamWriter.writeEndDocument();
        } catch (Exception ex) {
            getLogger().error("Error writing response", ex);
            throw new RuntimeException(ex);
        }
    }

    /**
     * Extracts the desired Response format from the Request. The default response format is XML.
     * The GeoGig Web API only supports XML and JSON responses (for requests that don't produce a
     * file output), therefore the returned format will be XML, unless the Request URI specifies
     * ".json" at the end, in which case, JSON would be the response format.
     *
     * @param request The Request from which to determine the desired Response format.
     *
     * @return A {@link MediaType} representation of the desired Response format, either
     *         {@link MediaType.APPLICATION_JSON} or {@link MediaType.APPLICATION_XML}.
     */
    protected final MediaType getMediaType(HttpServletRequest request) {
        final String requestURI = request.getRequestURI();
        if (requestURI != null && requestURI.endsWith(".json")) {
            return MediaType.APPLICATION_JSON;
        }
        return MediaType.APPLICATION_XML;
    }

    /**
     * Extracts the Base URL from the Request. This method is mainly used to encode other GeoGig
     * Web API request URLs to encode into a Response. For example:
     * <p>
     * <pre>GET http://localhost:8182/repos</pre>
     * <p>
     * would produce a list of currently configured GeoGig repositories. Each repository in the
     * list has a <b>link</b> element in the response that should be a URL to that repository's
     * info details, such as:
     * <p>
     * <pre>http://localhost:8182/repos/repo1.xml</pre>
     * <p>
     * If supplied the above <b>GET</b> request, this method should produce:
     * <p>
     * <pre>http://localhost:8182</pre>
     * <p>
     * <b>NOTE:</b> This method is not reliable in situations where firewalls, proxies, and other
     * redirect mechanisms are in place as the Request that reaches the server may be very different
     * from the request made by the end user.
     *
     * @param request The Request from which to extract the base URL
     *
     * @return A String representation of the GeoGig Web API base URL, from the server perspective.
     */
    protected final String getBaseUrl(HttpServletRequest request) {
        // Extract the baseURL from the request (NOTE: not reliable if proxies are involved)
        final String requestURL = HttpUtils.getRequestURL(request).toString();
        final String requestURI = request.getRequestURI();
        return requestURL.substring(0, requestURL.indexOf(requestURI));
    }

    /**
     * Builds a {@link MultiValueMapParams} from a {@link RequestEntity}. Currently only supports
     * JSON payload, and only basic JSON objects that are essentially key-value pairs, where the
     * values are primitives (String, numeric or boolean).
     * @param entity The RequestEntity payload, expected to be JSON.
     * @return a {@link MultiValueMapParams} instance with key-value pairs from the JSON entity, or
     * and empty instance if there is no body in the entity.
     */
    protected final ParameterSet getParamsFromEntity(RequestEntity<String> entity) {
        // attempt to build a parameter map from the request entity/payload
        if (entity != null && entity.hasBody()) {
            MediaType contentType = entity.getHeaders().getContentType();
            String body = entity.getBody();
            if (MediaType.APPLICATION_JSON.isCompatibleWith(contentType)) {
                // parse just a basic key-value styled JSON payload
                return handleJsonPayload(body);
            } else if (contentType.getSubtype().equals("xml")) {
                // handle XML payload
                return handleXmlPayload(body);
            } else {
                getLogger().error("RequestEntity does not have a JSON or XML payload. MediaType: " +
                        contentType);
            }
        }
        return ParameterSetFactory.buildEmptyParameterSet();
    }

    private ParameterSet handleJsonPayload(String body) {
        // parse just a basic key-value styled JSON payload
        JsonObject json = Json.createReader(new StringReader(body)).readObject();
        return ParameterSetFactory.buildParameterSet(json);
    }

    private ParameterSet handleXmlPayload(String body) {
        // this is a hack to handle specifically a POST with ConfigOp parameters "name" and "value".
        // It likely won't work with any other POSTed XML payload
        try {
            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
            InputSource xmlIn = new InputSource(new StringReader(body));
            Document doc = dBuilder.parse(xmlIn);
            doc.getDocumentElement().normalize();
            return ParameterSetFactory.buildParameterSet(doc);
        } catch (IOException | ParserConfigurationException | SAXException ex) {
            Throwables.propagate(ex);
        }
        return ParameterSetFactory.buildEmptyParameterSet();
    }
    /**
     * Returns sub-class specific {@link Logger} instance.
     *
     * @return sub-class specific {@link Logger} instance.
     */
    protected abstract Logger getLogger();
}
