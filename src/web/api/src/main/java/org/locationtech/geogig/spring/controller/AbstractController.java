/* Copyright (c) 2017 Boundless and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Distribution License v1.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/edl-v10.html
 *
 * Contributors:
 * Erik Merkle (Boundless) - initial implementation
 */
package org.locationtech.geogig.spring.controller;

import static org.locationtech.geogig.rest.repository.RepositoryProvider.GEOGIG_ROUTE_PREFIX;

import java.io.IOException;
import java.io.StringReader;
import java.util.Set;

import javax.json.Json;
import javax.json.JsonObject;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.locationtech.geogig.rest.Variants;
import org.locationtech.geogig.rest.repository.ParameterSetFactory;
import org.locationtech.geogig.rest.repository.RepositoryProvider;
import org.locationtech.geogig.spring.dto.LegacyResponse;
import org.locationtech.geogig.web.api.CommandSpecException;
import org.locationtech.geogig.web.api.ParameterSet;
import org.locationtech.geogig.web.api.StreamingWriter;
import org.slf4j.Logger;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.RequestEntity;
import org.w3c.dom.Document;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import com.google.common.base.Optional;

/**
 * Base Controller to hold common controller logic.
 */
public abstract class AbstractController {

    @Value(GEOGIG_ROUTE_PREFIX)
    private String geogigRoutePrefix;

    /**
     * Request parameter for requesting API version 2 responses. This is currently not supported
     * and may or may not ever come to fruition. If a controller wishes to support API version 2, it
     * should produce responses generated by the Spring MVC framework MessgaeConverters for
     * XML (JAXB2) and JSON (Google's Gson) when this parameter is in the request.
     */
    protected static final String API_V2 = "api_version=2";

    /**
     * Common 405 generator. Call this method from a controller to generate a 405.
     * @param methods list of supported methods
     */
    protected void supportedMethods(Set<String> methods) {
        throw new CommandSpecException("The request method is unsupported for this operation.",
                HttpStatus.METHOD_NOT_ALLOWED, methods);
    }

    /**
     * Exception for when no {@link RepositoryProvider} is provided in the request.
     */
    protected static final CommandSpecException NO_PROVIDER = new CommandSpecException(
            "RepositoryProvider not specified in request", HttpStatus.BAD_REQUEST);

    /**
     * Extracts the {@link RepositoryProvider} from the HTTP request. The {@link RepositoryProvider}
     * should be injected at server startup.
     *
     * @param request The request from which a RepositoryProvider should be extracted.
     *
     * @return An {@link Optional} of the RepositoryProvider from the request.
     */
    protected final Optional<RepositoryProvider> getRepoProvider(final HttpServletRequest request) {
        Object providerValue = request.getAttribute(RepositoryProvider.KEY);
        if (providerValue != null &&
                RepositoryProvider.class.isAssignableFrom(providerValue.getClass())) {
            return Optional.of((RepositoryProvider) providerValue);
        }
        return Optional.absent();
    }

    /**
     * Encodes the Response directly to the HTTP OutputStream. This method is to provide a way to
     * reuse the old Restlet Representation stream writing within the Spring MVC framework so that
     * the response format of GeoGig Web API requests remains the same.
     *
     * @param responseBean An encapsulated response object that can write itself to a
     *                     {@link StreamingWriter}.
     * @param request      The Request that produced the supplied responseBean.
     * @param response     The Response to which the responseBean should be written.
     */
    protected final void encode(LegacyResponse responseBean, final HttpServletRequest request,
            final HttpServletResponse response) {
        // Extract the baseURL from the request (NOTE: not reliable if proxies are involved)
        final String baseURL = getBaseUrl(request);
        // determine requested output format
        final MediaType requestedResponseFormat = responseBean
                .resolveMediaType(getMediaType(request));
        // set the Content-Type since we aren't using Spring's framework here
        response.setContentType(requestedResponseFormat.toString());
        // set the status
        response.setStatus(responseBean.getStatus().value());
        // write the LegacyResponse object out to the Response stream
        try {
            responseBean.encode(response.getWriter(), requestedResponseFormat, baseURL);
        } catch (IOException e) {
            throw new CommandSpecException("Error writing response",
                    HttpStatus.INTERNAL_SERVER_ERROR, e);
        }
    }

    /**
     * Extracts the desired Response format from the Request. The default response format is XML.
     * The GeoGig Web API only supports XML and JSON responses (for requests that don't produce a
     * file output), therefore the returned format will be XML, unless the Request URI specifies
     * ".json" at the end, in which case, JSON would be the response format.
     *
     * @param request The Request from which to determine the desired Response format.
     *
     * @return A {@link MediaType} representation of the desired Response format, either
     *         {@link MediaType.APPLICATION_JSON} or {@link MediaType.APPLICATION_XML}.
     */
    protected final MediaType getMediaType(HttpServletRequest request) {
        final String requestURI = request.getRequestURI();
        if (requestURI != null) {
            if (requestURI.endsWith(".json")) {
                return MediaType.APPLICATION_JSON;
            } else if (requestURI.endsWith(".csv")) {
                return Variants.CSV_MEDIA_TYPE;
            } else if (requestURI.endsWith(".xml")) {
                return MediaType.APPLICATION_XML;
            }
        }
        // no format specified on the Request URI, see if the "output_format" request parameter is
        // specified
        final String format = request.getParameter("output_format");
        if (format != null) {
            // output_format was specified, ensure it's a supported format
            if ("json".equalsIgnoreCase(format)) {
                return MediaType.APPLICATION_JSON;
            } else if ("csv".equalsIgnoreCase(format)) {
                return Variants.CSV_MEDIA_TYPE;
            } else if ("xml".equalsIgnoreCase(format)) {
                return MediaType.APPLICATION_XML;
            } else if ("gpkg".equalsIgnoreCase(format)) {
                return Variants.GEOPKG_MEDIA_TYPE;
            }
            else {
                // output_format specified, but not one we support
                throw new RuntimeException("Invalid output_format '" + format + "' requested");
            }
        }
        // return the default of XML
        return MediaType.APPLICATION_XML;
    }

    /**
     * Extracts the Base URL from the Request. This method is mainly used to encode other GeoGig
     * Web API request URLs to encode into a Response. For example:
     * <p>
     * <pre>GET http://localhost:8182/repos</pre>
     * <p>
     * would produce a list of currently configured GeoGig repositories. Each repository in the
     * list has a <b>link</b> element in the response that should be a URL to that repository's
     * info details, such as:
     * <p>
     * <pre>http://localhost:8182/repos/repo1.xml</pre>
     * <p>
     * If supplied the above <b>GET</b> request, this method should produce:
     * <p>
     * <pre>http://localhost:8182</pre>
     * <p>
     * <b>NOTE:</b> This method is not reliable in situations where firewalls, proxies, and other
     * redirect mechanisms are in place as the Request that reaches the server may be very different
     * from the request made by the end user.
     *
     * @param request The Request from which to extract the base URL
     *
     * @return A String representation of the GeoGig Web API base URL, from the server perspective.
     */
    protected final String getBaseUrl(HttpServletRequest request) {
        StringBuilder urlBuilder = new StringBuilder(request.getScheme());
        urlBuilder.append("://").append(request.getServerName());
        if (request.getServerPort() != 80) {
            urlBuilder.append(":").append(request.getServerPort());
        }
        urlBuilder.append(request.getContextPath()).append(geogigRoutePrefix);
        return urlBuilder.toString();
    }

    /**
     * Builds a {@link ParameterSet} from a {@link RequestEntity}. Currently only supports
     * JSON payload, and only basic JSON objects that are essentially key-value pairs, where the
     * values are primitives (String, numeric or boolean).
     * @param entity The RequestEntity payload, expected to be JSON.
     * @return a {@link ParameterSet} instance with key-value pairs from the JSON entity, or
     * and empty instance if there is no body in the entity.
     */
    protected final ParameterSet getParamsFromEntity(RequestEntity<String> entity) {
        // attempt to build a parameter map from the request entity/payload
        if (entity != null && entity.hasBody()) {
            MediaType contentType = entity.getHeaders().getContentType();
            String body = entity.getBody();
            if (MediaType.APPLICATION_JSON.isCompatibleWith(contentType)) {
                // parse just a basic key-value styled JSON payload
                return handleJsonPayload(body);
            } else if (contentType.getSubtype().equals("xml")) {
                // handle XML payload
                return handleXmlPayload(body);
            } else {
                getLogger().error("RequestEntity does not have a JSON or XML payload. MediaType: " +
                        contentType);
            }
        }
        return ParameterSetFactory.buildEmptyParameterSet();
    }

    private ParameterSet handleJsonPayload(String body) {
        // parse just a basic key-value styled JSON payload
        JsonObject json = Json.createReader(new StringReader(body)).readObject();
        return ParameterSetFactory.buildParameterSet(json);
    }

    private ParameterSet handleXmlPayload(String body) {
        // this is a hack to handle specifically a POST with ConfigOp parameters "name" and "value".
        // It likely won't work with any other POSTed XML payload
        try {
            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
            InputSource xmlIn = new InputSource(new StringReader(body));
            Document doc = dBuilder.parse(xmlIn);
            doc.getDocumentElement().normalize();
            return ParameterSetFactory.buildParameterSet(doc);
        } catch (IOException | ParserConfigurationException | SAXException ex) {
            getLogger().warn("Error handling XML contnet", ex);
        }
        return ParameterSetFactory.buildEmptyParameterSet();
    }

    /**
     * Returns sub-class specific {@link Logger} instance.
     *
     * @return sub-class specific {@link Logger} instance.
     */
    protected abstract Logger getLogger();
}
